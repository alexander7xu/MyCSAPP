# C3 - Machine-Level Representation of Programs

## 3.2 Program Encodings

### 3.2.1 Machine-Level Code

The assembly-code representation is very close to machine code. Its main feature is that it is in a more readable textual format, as compared to the binary format of machine code. Being able to understand assembly code and how it relates to the original C code is a key step in understanding how computers execute programs.

### 3.2.2 Code Examples

```c
long mult2(long, long);
void multstore(long x, long y, long *dest) {
  long t = mult2(x, y);
  *dest = t;
}
```

Windows (gcc.exe -Og -S, v8.1.0, MinGW-W64 x86_64-posix-seh-rev0)

```x86asm
multstore:
	pushq	%rbx
	.seh_pushreg	%rbx
	subq	$32, %rsp
	.seh_stackalloc	32
	.seh_endprologue
	movq	%r8, %rbx
	call	mult2
	movl	%eax, (%rbx)
	addq	$32, %rsp
	popq	%rbx
	ret
```

Linux (gcc -Og -S, v9.3.0, Ubuntu 9.3.0-17ubuntu1~20.04)

```x86asm
multstore:
.LFB0:
        .cfi_startproc
        endbr64
        pushq   %rbx
        .cfi_def_cfa_offset 16
        .cfi_offset 3, -16
        movq    %rdx, %rbx
        call    mult2@PLT
        movq    %rax, (%rbx)
        popq    %rbx
        .cfi_def_cfa_offset 8
        ret
```

#### Several features about machine code and its disassembled representation are worth noting:
- x86-64 instructions can range in length from 1 to 15 bytes. The instruction encoding is designed so that commonly used instructions and those with fewer operands require a smaller number of bytes than do less common ones or ones with more operands.
- The instruction format is designed in such a way that from a given starting position, there is a unique decoding of the bytes into machine instructions. For example, only the instruction pushq %rbx can start with byte value 53.
- The disassembler determines the assembly code based purely on the byte sequences in the machine-code file. It does not require access to the source or assembly-code versions of the program.
- The disassembler uses a slightly different naming convention for the instructions than does the assembly code generated by gcc. In our example, it has omitted the suffix ‘q’ from many of the instructions. These suffixes are size designators and can be omitted in most cases. Conversely, the disassembler adds the suffix ‘q’tothe call and ret instructions. Again, these suffixes can safely be omitted.

## 3.3 Data Formats

Due to its origins as a 16-bit architecture that expanded into a 32-bit one, Intel uses the term “word” to refer to a 16-bit data type.

**(long double) We recommend against using this format, however. It is not portable to other classes of machines, and it is typically not implemented with the same high-performance hardware as is the case for single- and double-precision arithmetic.**

The suffix ‘l’ is used for double words, since 32-bit quantities are considered to be “long words.” The assembly code uses the suffix ‘l’ to denote a 4-byte integer as well as an 8-byte double-precision floating-point number. This causes no ambiguity, since floating-point code involves an entirely different set of instructions and registers.

## 3.4 Accessing Information

The original 8086 had eight 16-bit registers, shown in Figure 3.2 as registers `%ax` through `%bp`. Each had a specific purpose, and hence they were given names that reflected how they were to be used.With the extension to IA32, these registers were expanded to 32-bit registers, labeled %eax through `%ebp`. In the extension to x86-64, the original eight registers were expanded to 64 bits, labeled `%rax` through `%rbp`. In addition, eight new registers were added, and these were given labels according to a new naming convention: `%r8` through `%r15`.

**Most unique among them is the stack pointer, `%rsp`, used to indicate the end position in the run-time stack. Some instructions specifically read and write this register.**

### 3.4.1 Operand Specifiers

The most general form (of memory references) is $Imm(r_b,r_i,s)$. The effective address is computed as $Imm+R[r_b]+R[r_i]*s$.

### 3.4.2 Data Movement Instructions

x86-64 imposes the restriction that a move instruction cannot have both operands refer to memory locations. Copying a value from one memory location to another requires two instructions—the first to load the source value into a register, and the second to write this register value to the destination.

For most cases, the `MOV` instructions will only update the specific register bytes or memory locations indicated by the destination operand. The only exception is that **when `movl` has a register as the destination, it will also set the high-order 4 bytes of the register to 0.**

**The regular `movq` instruction can only have immediate source operands that can be represented as 32-bit two’s-complement numbers.** This value is then sign extended to produce the 64-bit value for the destination. The `movabsq` instruction can have an arbitrary 64-bit immediate value as its source operand and can only have a register as a destination.

[Why is the copying instruction usually named MOV?](https://softwareengineering.stackexchange.com/questions/222254/why-is-the-copying-instruction-usually-named-mov)

> Sometimes the source registers is still meaningful after a register-transfer instruction, but since there's nothing in the instruction set to indicate whether it will be, and in many common situations it isn't, "move" seems reasonable.

### 3.4.3 Data Movement Example

A function returns a value by storing it in register %rax, or in one of the low-order portions of this register.

```c
long exchange(long *xp, long y) {
  long x = *xp;
  *xp = y;
  return x;
}
```

Windows

```x86asm
movl	(%rcx), %eax
movl	%edx, (%rcx)
ret
```

*Note that sizeof(long) is 4 here*

Linux

```x86asm
movq    (%rdi), %rax
movq    %rsi, (%rdi)
ret
```

### 3.4.4 Pushing and Popping Stack Data

the stack grows downward such that the top element of the stack has the lowest address of all stack elements. The stack pointer %rsp holds the address of the top stack element.

Pushing a quad word value onto the stack involves first decrementing the stack pointer by 8 and then writing the value at the new top-of-stack address.

Since the stack is contained in the same memory as the program code and other forms of program data, programs can access arbitrary positions within the stack using the standard memory addressing methods. For example, assuming the topmost element of the stack is a quad word, the instruction `movq 8(%rsp),%rdx` will copy the second quad word from the stack to register `%rdx`.

### Summary of Accessing Information

#### Registers

| 63~32 | 31~16 | 15~8 | 7~0 | purpose |
|-|-|-|-|-|
| `%rax` | `%eax` | `%ax` | `%al` | temp register; return value |
| `%rbx` | `%ebx` | `%bx` | `%bl` | callee-saved |
| `%rcx` | `%ecx` | `%cx` | `%cl` | pass 4th argument to functions |
| `%rdx` | `%edx` | `%dx` | `%dl` | pass 3rd argument to functions |
| `%rsi` | `%esi` | `%si` | `%sil` | pass 2nd argument to functions |
| `%rdi` | `%edi` | `%di` | `%dil` | pass 1st argument to functions |
| `%rsp` | `%esp` | `%sp` | `%spl` | stack pointer |
| `%rbp` | `%ebp` | `%bp` | `%bpl` | callee-saved; stack base pointer |
| `%r8` | `%r8d` | `%r8w` | `%r8b` | pass 5th argument to functions |
| `%r9` | `%r9d` | `%r9w` | `%r9b` | pass 6th argument to functions |
| `%r10`-`%r11` | `%r10d`-`%r11d` | `%r10w`-`%r10w` | `%r10b`-`%r10b` | temporary |
| `%r12`-`%r15` | `%r12d`-`%r15d` | `%r12w`-`%r15w` | `%r12b`-`%r15b` | callee-saved |

#### Instructions

| Instruction | Description | Note |
|-|-|-|
| `movT` S, D | move S to D  | T={b,w,l,q}; S and D cannot both refer to memory locations |
| `movabsq` I, R | move I to R  | I is an immediate value and R is a register |
| `movzTT` S, R | move with zero extension  | TT={bw,bl,bq,wl,wq}; no `movzlq` cuz `movl` will do |
| `pushT` S | expand stack with `sizeof(T)`, then move S to the top | stack[++top] = S |
| `popT` D | get stack top, then shrink stack with `sizeof(T)` | D = stack[top--] |

## 3.5 Arithmetic and Logical Operations

### 3.5.1 Load Effective Address

The load effective address instruction `leaq` is actually a variant of the `movq` instruction. But it does not reference memory at all. Its first operand appears to be a memory reference, but instead of reading from the designated location, the instruction copies the effective address to the destination.

```c
void *ptrplus(void *base, int64_t offset) { return base + offset; }
```

Linux

```x86asm
leaq    (%rdi,%rsi), %rax
ret
```

### 3.5.3 Shift Operations

shift instructions can specify the shift amount **either as an immediate value or with the single-byte register `%cl`.** (These instructions are unusual in only allowing this specific register as the operand.)

With x86-64, a shift instruction operating on data values that are $w$ bits long determines the shift amount from the low-order $m$ bits of register `%cl`, where $2^m = w$. The higher-order bits are ignored. So, for example, when register `%cl` has hexadecimal value 0xFF, then instruction `salb` would shift by 7, while `salw` would shift by 15, `sall` would shift by 31, and `salq` would shift by 63.

### 3.5.4 Discussion

Practice Problem 3.11
Compare the number of bytes to encode any two of these three different implementations of the same operation.

```x86asm
movl    $0, %eax
xorl    $0, %eax
```

in gdb:

```
0x55555555512d <main+4>                   mov    eax, 0
0x555555555132 <main+9>                   xor    eax, 0
0x555555555135 <main+12>                  ret    
```

the version with `xor` requires only 3 bytes, while the version with `mov` requires 7.

### 3.5.5 Special Arithmetic Operations

Intel refers to a 16-byte quantity as an oct word. C standard does not make provisions for 128-bit values, the support provided by gcc for 128-bit integers declared using the name `__int128`.

In session 2.3.5 we have learnt that:
> Although the bit-level representations of the full products may differ, **those of the truncated products are identical.**

For `imulT` (Multiply discard overflowed bits), no matter signed or unsigned multiply, the CPU do the same calculation indeed. But for full multiply, the products may differ, so we need `mulT`.

For both of `imulT` and `mulT`, **one argument must be in register `%rax`**, and the other is given as the instruction source operand. The product is then stored in registers `%rdx` (high-order 64 bits) and `%rax `(low-order 64 bits), ***it seems like `imul S, %rax` with storing the overflowed bits in `%rdx`***. Although the name imulq is used for two distinct multiplication operations, the assembler can tell which one is intended by counting the number of operands.

The signed division instruction `idivl` takes as its dividend the 128-bit quantity in registers `%rdx` (high-order 64 bits) and `%rax` (low-order 64 bits). The divisor is given as the instruction operand. The instruction stores the quotient in register
`%rax` and the remainder in register `%rdx`.

For most applications of 64-bit addition, the dividend is given as a 64-bit value. This value should be stored in register `%rax`. **The bits of `%rdx` should then be set to either all zeros (unsigned arithmetic) or the sign bit of `%rax` (signed arithmetic).** The latter operation can be performed using the instruction cqto. This instruction takes no operands—it implicitly reads the sign bit from `%rax` and copies it across all of `%rdx`.

```c
void remdiv(int64_t x, int64_t y, int64_t *qp, int64_t *rp) {
  int64_t q = x / y;
  int64_t r = x % y;
  *qp = q;
  *rp = r;
}
```

```x86asm
movq    %rdi, %rax
movq    %rdx, %r8
cqto
idivq   %rsi
movq    %rax, (%r8)
movq    %rdx, (%rcx)
ret
```

### Summary of Arithmetic and Logical Operations

#### Integer arithmetic operations

| Instruction | Description | Note |
|-|-|-|
| `leaT` S, D | Load effective address | D = &S |
| `incT` D | Increment | ++D |
| `decT` D | Decrement | --D |
| `negT` D | Negate | D = -D |
| `notT` D | Complement | D = ~D |
| `addT` S, D | Add | D += S |
| `subT` S, D | Subtract | D -= S |
| `imulT` S, D | **Multiply (discard overflowed bits)** | D *= S |
| `xorT` S, D | Exclusive-or | D ^= S |
| `orT` S, D | Or | D \|= S |
| `andT` S, D | And | D &= S |
| `salT` k, D | Left shift | D <= k |
| `shlT` k, D | Left shift (same as sal) | D <= k |
| `sarT` k, D | Arithmetic right shift | D >= k |
| `shrT` k, D | Logical right shift | D >= k |

#### Special Arithmetic Operations

| Instruction | Description | Note |
|-|-|-|
| `imulT` S | **Signed full Multiply** | `%rdx:%rax` = `%rax` * S |
| `mulT` S | **Unsigned full Multiply** | `%rdx:%rax` = `%rax` * S |
| `idivT` S | Signed divide | `%rax` = `%rdx:%rax` / S; `%rdx` = `%rdx:%rax` % S |
| `divT` S | Unsigned divide | `%rax` = `%rdx:%rax` / S; `%rdx` = `%rdx:%rax` % S  |
| `cqto` | Convert to oct word (16-byte) (SignExtend) | copies sign bit from `%rax` across all of `%rdx` |

